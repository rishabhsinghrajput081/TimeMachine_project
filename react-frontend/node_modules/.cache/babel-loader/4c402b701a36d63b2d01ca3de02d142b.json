{"ast":null,"code":"import { Controls, MOUSE, Quaternion, Spherical, TOUCH, Vector2, Vector3, Plane, Ray, MathUtils } from 'three';\n\n// OrbitControls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one-finger move\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\n\nconst _changeEvent = {\n  type: 'change'\n};\nconst _startEvent = {\n  type: 'start'\n};\nconst _endEvent = {\n  type: 'end'\n};\nconst _ray = new Ray();\nconst _plane = new Plane();\nconst _TILT_LIMIT = Math.cos(70 * MathUtils.DEG2RAD);\nconst _v = new Vector3();\nconst _twoPI = 2 * Math.PI;\nconst _STATE = {\n  NONE: -1,\n  ROTATE: 0,\n  DOLLY: 1,\n  PAN: 2,\n  TOUCH_ROTATE: 3,\n  TOUCH_PAN: 4,\n  TOUCH_DOLLY_PAN: 5,\n  TOUCH_DOLLY_ROTATE: 6\n};\nconst _EPS = 0.000001;\nclass OrbitControls extends Controls {\n  constructor(object, domElement = null) {\n    super(object, domElement);\n    this.state = _STATE.NONE;\n\n    // Set to false to disable this control\n    this.enabled = true;\n\n    // \"target\" sets the location of focus, where the object orbits around\n    this.target = new Vector3();\n\n    // Sets the 3D cursor (similar to Blender), from which the maxTargetRadius takes effect\n    this.cursor = new Vector3();\n\n    // How far you can dolly in and out ( PerspectiveCamera only )\n    this.minDistance = 0;\n    this.maxDistance = Infinity;\n\n    // How far you can zoom in and out ( OrthographicCamera only )\n    this.minZoom = 0;\n    this.maxZoom = Infinity;\n\n    // Limit camera target within a spherical area around the cursor\n    this.minTargetRadius = 0;\n    this.maxTargetRadius = Infinity;\n\n    // How far you can orbit vertically, upper and lower limits.\n    // Range is 0 to Math.PI radians.\n    this.minPolarAngle = 0; // radians\n    this.maxPolarAngle = Math.PI; // radians\n\n    // How far you can orbit horizontally, upper and lower limits.\n    // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )\n    this.minAzimuthAngle = -Infinity; // radians\n    this.maxAzimuthAngle = Infinity; // radians\n\n    // Set to true to enable damping (inertia)\n    // If damping is enabled, you must call controls.update() in your animation loop\n    this.enableDamping = false;\n    this.dampingFactor = 0.05;\n\n    // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n    // Set to false to disable zooming\n    this.enableZoom = true;\n    this.zoomSpeed = 1.0;\n\n    // Set to false to disable rotating\n    this.enableRotate = true;\n    this.rotateSpeed = 1.0;\n\n    // Set to false to disable panning\n    this.enablePan = true;\n    this.panSpeed = 1.0;\n    this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up\n    this.keyPanSpeed = 7.0; // pixels moved per arrow key push\n    this.zoomToCursor = false;\n\n    // Set to true to automatically rotate around the target\n    // If auto-rotate is enabled, you must call controls.update() in your animation loop\n    this.autoRotate = false;\n    this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60\n\n    // The four arrow keys\n    this.keys = {\n      LEFT: 'ArrowLeft',\n      UP: 'ArrowUp',\n      RIGHT: 'ArrowRight',\n      BOTTOM: 'ArrowDown'\n    };\n\n    // Mouse buttons\n    this.mouseButtons = {\n      LEFT: MOUSE.ROTATE,\n      MIDDLE: MOUSE.DOLLY,\n      RIGHT: MOUSE.PAN\n    };\n\n    // Touch fingers\n    this.touches = {\n      ONE: TOUCH.ROTATE,\n      TWO: TOUCH.DOLLY_PAN\n    };\n\n    // for reset\n    this.target0 = this.target.clone();\n    this.position0 = this.object.position.clone();\n    this.zoom0 = this.object.zoom;\n\n    // the target DOM element for key events\n    this._domElementKeyEvents = null;\n\n    // internals\n\n    this._lastPosition = new Vector3();\n    this._lastQuaternion = new Quaternion();\n    this._lastTargetPosition = new Vector3();\n\n    // so camera.up is the orbit axis\n    this._quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));\n    this._quatInverse = this._quat.clone().invert();\n\n    // current position in spherical coordinates\n    this._spherical = new Spherical();\n    this._sphericalDelta = new Spherical();\n    this._scale = 1;\n    this._panOffset = new Vector3();\n    this._rotateStart = new Vector2();\n    this._rotateEnd = new Vector2();\n    this._rotateDelta = new Vector2();\n    this._panStart = new Vector2();\n    this._panEnd = new Vector2();\n    this._panDelta = new Vector2();\n    this._dollyStart = new Vector2();\n    this._dollyEnd = new Vector2();\n    this._dollyDelta = new Vector2();\n    this._dollyDirection = new Vector3();\n    this._mouse = new Vector2();\n    this._performCursorZoom = false;\n    this._pointers = [];\n    this._pointerPositions = {};\n    this._controlActive = false;\n\n    // event listeners\n\n    this._onPointerMove = onPointerMove.bind(this);\n    this._onPointerDown = onPointerDown.bind(this);\n    this._onPointerUp = onPointerUp.bind(this);\n    this._onContextMenu = onContextMenu.bind(this);\n    this._onMouseWheel = onMouseWheel.bind(this);\n    this._onKeyDown = onKeyDown.bind(this);\n    this._onTouchStart = onTouchStart.bind(this);\n    this._onTouchMove = onTouchMove.bind(this);\n    this._onMouseDown = onMouseDown.bind(this);\n    this._onMouseMove = onMouseMove.bind(this);\n    this._interceptControlDown = interceptControlDown.bind(this);\n    this._interceptControlUp = interceptControlUp.bind(this);\n\n    //\n\n    if (this.domElement !== null) {\n      this.connect();\n    }\n    this.update();\n  }\n  connect() {\n    this.domElement.addEventListener('pointerdown', this._onPointerDown);\n    this.domElement.addEventListener('pointercancel', this._onPointerUp);\n    this.domElement.addEventListener('contextmenu', this._onContextMenu);\n    this.domElement.addEventListener('wheel', this._onMouseWheel, {\n      passive: false\n    });\n    const document = this.domElement.getRootNode(); // offscreen canvas compatibility\n    document.addEventListener('keydown', this._interceptControlDown, {\n      passive: true,\n      capture: true\n    });\n    this.domElement.style.touchAction = 'none'; // disable touch scroll\n  }\n  disconnect() {\n    this.domElement.removeEventListener('pointerdown', this._onPointerDown);\n    this.domElement.removeEventListener('pointermove', this._onPointerMove);\n    this.domElement.removeEventListener('pointerup', this._onPointerUp);\n    this.domElement.removeEventListener('pointercancel', this._onPointerUp);\n    this.domElement.removeEventListener('wheel', this._onMouseWheel);\n    this.domElement.removeEventListener('contextmenu', this._onContextMenu);\n    this.stopListenToKeyEvents();\n    const document = this.domElement.getRootNode(); // offscreen canvas compatibility\n    document.removeEventListener('keydown', this._interceptControlDown, {\n      capture: true\n    });\n    this.domElement.style.touchAction = 'auto';\n  }\n  dispose() {\n    this.disconnect();\n  }\n  getPolarAngle() {\n    return this._spherical.phi;\n  }\n  getAzimuthalAngle() {\n    return this._spherical.theta;\n  }\n  getDistance() {\n    return this.object.position.distanceTo(this.target);\n  }\n  listenToKeyEvents(domElement) {\n    domElement.addEventListener('keydown', this._onKeyDown);\n    this._domElementKeyEvents = domElement;\n  }\n  stopListenToKeyEvents() {\n    if (this._domElementKeyEvents !== null) {\n      this._domElementKeyEvents.removeEventListener('keydown', this._onKeyDown);\n      this._domElementKeyEvents = null;\n    }\n  }\n  saveState() {\n    this.target0.copy(this.target);\n    this.position0.copy(this.object.position);\n    this.zoom0 = this.object.zoom;\n  }\n  reset() {\n    this.target.copy(this.target0);\n    this.object.position.copy(this.position0);\n    this.object.zoom = this.zoom0;\n    this.object.updateProjectionMatrix();\n    this.dispatchEvent(_changeEvent);\n    this.update();\n    this.state = _STATE.NONE;\n  }\n  update(deltaTime = null) {\n    const position = this.object.position;\n    _v.copy(position).sub(this.target);\n\n    // rotate offset to \"y-axis-is-up\" space\n    _v.applyQuaternion(this._quat);\n\n    // angle from z-axis around y-axis\n    this._spherical.setFromVector3(_v);\n    if (this.autoRotate && this.state === _STATE.NONE) {\n      this._rotateLeft(this._getAutoRotationAngle(deltaTime));\n    }\n    if (this.enableDamping) {\n      this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor;\n      this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor;\n    } else {\n      this._spherical.theta += this._sphericalDelta.theta;\n      this._spherical.phi += this._sphericalDelta.phi;\n    }\n\n    // restrict theta to be between desired limits\n\n    let min = this.minAzimuthAngle;\n    let max = this.maxAzimuthAngle;\n    if (isFinite(min) && isFinite(max)) {\n      if (min < -Math.PI) min += _twoPI;else if (min > Math.PI) min -= _twoPI;\n      if (max < -Math.PI) max += _twoPI;else if (max > Math.PI) max -= _twoPI;\n      if (min <= max) {\n        this._spherical.theta = Math.max(min, Math.min(max, this._spherical.theta));\n      } else {\n        this._spherical.theta = this._spherical.theta > (min + max) / 2 ? Math.max(min, this._spherical.theta) : Math.min(max, this._spherical.theta);\n      }\n    }\n\n    // restrict phi to be between desired limits\n    this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi));\n    this._spherical.makeSafe();\n\n    // move target to panned location\n\n    if (this.enableDamping === true) {\n      this.target.addScaledVector(this._panOffset, this.dampingFactor);\n    } else {\n      this.target.add(this._panOffset);\n    }\n\n    // Limit the target distance from the cursor to create a sphere around the center of interest\n    this.target.sub(this.cursor);\n    this.target.clampLength(this.minTargetRadius, this.maxTargetRadius);\n    this.target.add(this.cursor);\n    let zoomChanged = false;\n    // adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera\n    // we adjust zoom later in these cases\n    if (this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera) {\n      this._spherical.radius = this._clampDistance(this._spherical.radius);\n    } else {\n      const prevRadius = this._spherical.radius;\n      this._spherical.radius = this._clampDistance(this._spherical.radius * this._scale);\n      zoomChanged = prevRadius != this._spherical.radius;\n    }\n    _v.setFromSpherical(this._spherical);\n\n    // rotate offset back to \"camera-up-vector-is-up\" space\n    _v.applyQuaternion(this._quatInverse);\n    position.copy(this.target).add(_v);\n    this.object.lookAt(this.target);\n    if (this.enableDamping === true) {\n      this._sphericalDelta.theta *= 1 - this.dampingFactor;\n      this._sphericalDelta.phi *= 1 - this.dampingFactor;\n      this._panOffset.multiplyScalar(1 - this.dampingFactor);\n    } else {\n      this._sphericalDelta.set(0, 0, 0);\n      this._panOffset.set(0, 0, 0);\n    }\n\n    // adjust camera position\n    if (this.zoomToCursor && this._performCursorZoom) {\n      let newRadius = null;\n      if (this.object.isPerspectiveCamera) {\n        // move the camera down the pointer ray\n        // this method avoids floating point error\n        const prevRadius = _v.length();\n        newRadius = this._clampDistance(prevRadius * this._scale);\n        const radiusDelta = prevRadius - newRadius;\n        this.object.position.addScaledVector(this._dollyDirection, radiusDelta);\n        this.object.updateMatrixWorld();\n        zoomChanged = !!radiusDelta;\n      } else if (this.object.isOrthographicCamera) {\n        // adjust the ortho camera position based on zoom changes\n        const mouseBefore = new Vector3(this._mouse.x, this._mouse.y, 0);\n        mouseBefore.unproject(this.object);\n        const prevZoom = this.object.zoom;\n        this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale));\n        this.object.updateProjectionMatrix();\n        zoomChanged = prevZoom !== this.object.zoom;\n        const mouseAfter = new Vector3(this._mouse.x, this._mouse.y, 0);\n        mouseAfter.unproject(this.object);\n        this.object.position.sub(mouseAfter).add(mouseBefore);\n        this.object.updateMatrixWorld();\n        newRadius = _v.length();\n      } else {\n        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.');\n        this.zoomToCursor = false;\n      }\n\n      // handle the placement of the target\n      if (newRadius !== null) {\n        if (this.screenSpacePanning) {\n          // position the orbit target in front of the new camera position\n          this.target.set(0, 0, -1).transformDirection(this.object.matrix).multiplyScalar(newRadius).add(this.object.position);\n        } else {\n          // get the ray and translation plane to compute target\n          _ray.origin.copy(this.object.position);\n          _ray.direction.set(0, 0, -1).transformDirection(this.object.matrix);\n\n          // if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid\n          // extremely large values\n          if (Math.abs(this.object.up.dot(_ray.direction)) < _TILT_LIMIT) {\n            this.object.lookAt(this.target);\n          } else {\n            _plane.setFromNormalAndCoplanarPoint(this.object.up, this.target);\n            _ray.intersectPlane(_plane, this.target);\n          }\n        }\n      }\n    } else if (this.object.isOrthographicCamera) {\n      const prevZoom = this.object.zoom;\n      this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale));\n      if (prevZoom !== this.object.zoom) {\n        this.object.updateProjectionMatrix();\n        zoomChanged = true;\n      }\n    }\n    this._scale = 1;\n    this._performCursorZoom = false;\n\n    // update condition is:\n    // min(camera displacement, camera rotation in radians)^2 > EPS\n    // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n    if (zoomChanged || this._lastPosition.distanceToSquared(this.object.position) > _EPS || 8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > _EPS || this._lastTargetPosition.distanceToSquared(this.target) > _EPS) {\n      this.dispatchEvent(_changeEvent);\n      this._lastPosition.copy(this.object.position);\n      this._lastQuaternion.copy(this.object.quaternion);\n      this._lastTargetPosition.copy(this.target);\n      return true;\n    }\n    return false;\n  }\n  _getAutoRotationAngle(deltaTime) {\n    if (deltaTime !== null) {\n      return _twoPI / 60 * this.autoRotateSpeed * deltaTime;\n    } else {\n      return _twoPI / 60 / 60 * this.autoRotateSpeed;\n    }\n  }\n  _getZoomScale(delta) {\n    const normalizedDelta = Math.abs(delta * 0.01);\n    return Math.pow(0.95, this.zoomSpeed * normalizedDelta);\n  }\n  _rotateLeft(angle) {\n    this._sphericalDelta.theta -= angle;\n  }\n  _rotateUp(angle) {\n    this._sphericalDelta.phi -= angle;\n  }\n  _panLeft(distance, objectMatrix) {\n    _v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix\n    _v.multiplyScalar(-distance);\n    this._panOffset.add(_v);\n  }\n  _panUp(distance, objectMatrix) {\n    if (this.screenSpacePanning === true) {\n      _v.setFromMatrixColumn(objectMatrix, 1);\n    } else {\n      _v.setFromMatrixColumn(objectMatrix, 0);\n      _v.crossVectors(this.object.up, _v);\n    }\n    _v.multiplyScalar(distance);\n    this._panOffset.add(_v);\n  }\n\n  // deltaX and deltaY are in pixels; right and down are positive\n  _pan(deltaX, deltaY) {\n    const element = this.domElement;\n    if (this.object.isPerspectiveCamera) {\n      // perspective\n      const position = this.object.position;\n      _v.copy(position).sub(this.target);\n      let targetDistance = _v.length();\n\n      // half of the fov is center to top of screen\n      targetDistance *= Math.tan(this.object.fov / 2 * Math.PI / 180.0);\n\n      // we use only clientHeight here so aspect ratio does not distort speed\n      this._panLeft(2 * deltaX * targetDistance / element.clientHeight, this.object.matrix);\n      this._panUp(2 * deltaY * targetDistance / element.clientHeight, this.object.matrix);\n    } else if (this.object.isOrthographicCamera) {\n      // orthographic\n      this._panLeft(deltaX * (this.object.right - this.object.left) / this.object.zoom / element.clientWidth, this.object.matrix);\n      this._panUp(deltaY * (this.object.top - this.object.bottom) / this.object.zoom / element.clientHeight, this.object.matrix);\n    } else {\n      // camera neither orthographic nor perspective\n      console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');\n      this.enablePan = false;\n    }\n  }\n  _dollyOut(dollyScale) {\n    if (this.object.isPerspectiveCamera || this.object.isOrthographicCamera) {\n      this._scale /= dollyScale;\n    } else {\n      console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');\n      this.enableZoom = false;\n    }\n  }\n  _dollyIn(dollyScale) {\n    if (this.object.isPerspectiveCamera || this.object.isOrthographicCamera) {\n      this._scale *= dollyScale;\n    } else {\n      console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');\n      this.enableZoom = false;\n    }\n  }\n  _updateZoomParameters(x, y) {\n    if (!this.zoomToCursor) {\n      return;\n    }\n    this._performCursorZoom = true;\n    const rect = this.domElement.getBoundingClientRect();\n    const dx = x - rect.left;\n    const dy = y - rect.top;\n    const w = rect.width;\n    const h = rect.height;\n    this._mouse.x = dx / w * 2 - 1;\n    this._mouse.y = -(dy / h) * 2 + 1;\n    this._dollyDirection.set(this._mouse.x, this._mouse.y, 1).unproject(this.object).sub(this.object.position).normalize();\n  }\n  _clampDistance(dist) {\n    return Math.max(this.minDistance, Math.min(this.maxDistance, dist));\n  }\n\n  //\n  // event callbacks - update the object state\n  //\n\n  _handleMouseDownRotate(event) {\n    this._rotateStart.set(event.clientX, event.clientY);\n  }\n  _handleMouseDownDolly(event) {\n    this._updateZoomParameters(event.clientX, event.clientX);\n    this._dollyStart.set(event.clientX, event.clientY);\n  }\n  _handleMouseDownPan(event) {\n    this._panStart.set(event.clientX, event.clientY);\n  }\n  _handleMouseMoveRotate(event) {\n    this._rotateEnd.set(event.clientX, event.clientY);\n    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);\n    const element = this.domElement;\n    this._rotateLeft(_twoPI * this._rotateDelta.x / element.clientHeight); // yes, height\n\n    this._rotateUp(_twoPI * this._rotateDelta.y / element.clientHeight);\n    this._rotateStart.copy(this._rotateEnd);\n    this.update();\n  }\n  _handleMouseMoveDolly(event) {\n    this._dollyEnd.set(event.clientX, event.clientY);\n    this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart);\n    if (this._dollyDelta.y > 0) {\n      this._dollyOut(this._getZoomScale(this._dollyDelta.y));\n    } else if (this._dollyDelta.y < 0) {\n      this._dollyIn(this._getZoomScale(this._dollyDelta.y));\n    }\n    this._dollyStart.copy(this._dollyEnd);\n    this.update();\n  }\n  _handleMouseMovePan(event) {\n    this._panEnd.set(event.clientX, event.clientY);\n    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed);\n    this._pan(this._panDelta.x, this._panDelta.y);\n    this._panStart.copy(this._panEnd);\n    this.update();\n  }\n  _handleMouseWheel(event) {\n    this._updateZoomParameters(event.clientX, event.clientY);\n    if (event.deltaY < 0) {\n      this._dollyIn(this._getZoomScale(event.deltaY));\n    } else if (event.deltaY > 0) {\n      this._dollyOut(this._getZoomScale(event.deltaY));\n    }\n    this.update();\n  }\n  _handleKeyDown(event) {\n    let needsUpdate = false;\n    switch (event.code) {\n      case this.keys.UP:\n        if (event.ctrlKey || event.metaKey || event.shiftKey) {\n          this._rotateUp(_twoPI * this.rotateSpeed / this.domElement.clientHeight);\n        } else {\n          this._pan(0, this.keyPanSpeed);\n        }\n        needsUpdate = true;\n        break;\n      case this.keys.BOTTOM:\n        if (event.ctrlKey || event.metaKey || event.shiftKey) {\n          this._rotateUp(-_twoPI * this.rotateSpeed / this.domElement.clientHeight);\n        } else {\n          this._pan(0, -this.keyPanSpeed);\n        }\n        needsUpdate = true;\n        break;\n      case this.keys.LEFT:\n        if (event.ctrlKey || event.metaKey || event.shiftKey) {\n          this._rotateLeft(_twoPI * this.rotateSpeed / this.domElement.clientHeight);\n        } else {\n          this._pan(this.keyPanSpeed, 0);\n        }\n        needsUpdate = true;\n        break;\n      case this.keys.RIGHT:\n        if (event.ctrlKey || event.metaKey || event.shiftKey) {\n          this._rotateLeft(-_twoPI * this.rotateSpeed / this.domElement.clientHeight);\n        } else {\n          this._pan(-this.keyPanSpeed, 0);\n        }\n        needsUpdate = true;\n        break;\n    }\n    if (needsUpdate) {\n      // prevent the browser from scrolling on cursor keys\n      event.preventDefault();\n      this.update();\n    }\n  }\n  _handleTouchStartRotate(event) {\n    if (this._pointers.length === 1) {\n      this._rotateStart.set(event.pageX, event.pageY);\n    } else {\n      const position = this._getSecondPointerPosition(event);\n      const x = 0.5 * (event.pageX + position.x);\n      const y = 0.5 * (event.pageY + position.y);\n      this._rotateStart.set(x, y);\n    }\n  }\n  _handleTouchStartPan(event) {\n    if (this._pointers.length === 1) {\n      this._panStart.set(event.pageX, event.pageY);\n    } else {\n      const position = this._getSecondPointerPosition(event);\n      const x = 0.5 * (event.pageX + position.x);\n      const y = 0.5 * (event.pageY + position.y);\n      this._panStart.set(x, y);\n    }\n  }\n  _handleTouchStartDolly(event) {\n    const position = this._getSecondPointerPosition(event);\n    const dx = event.pageX - position.x;\n    const dy = event.pageY - position.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    this._dollyStart.set(0, distance);\n  }\n  _handleTouchStartDollyPan(event) {\n    if (this.enableZoom) this._handleTouchStartDolly(event);\n    if (this.enablePan) this._handleTouchStartPan(event);\n  }\n  _handleTouchStartDollyRotate(event) {\n    if (this.enableZoom) this._handleTouchStartDolly(event);\n    if (this.enableRotate) this._handleTouchStartRotate(event);\n  }\n  _handleTouchMoveRotate(event) {\n    if (this._pointers.length == 1) {\n      this._rotateEnd.set(event.pageX, event.pageY);\n    } else {\n      const position = this._getSecondPointerPosition(event);\n      const x = 0.5 * (event.pageX + position.x);\n      const y = 0.5 * (event.pageY + position.y);\n      this._rotateEnd.set(x, y);\n    }\n    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);\n    const element = this.domElement;\n    this._rotateLeft(_twoPI * this._rotateDelta.x / element.clientHeight); // yes, height\n\n    this._rotateUp(_twoPI * this._rotateDelta.y / element.clientHeight);\n    this._rotateStart.copy(this._rotateEnd);\n  }\n  _handleTouchMovePan(event) {\n    if (this._pointers.length === 1) {\n      this._panEnd.set(event.pageX, event.pageY);\n    } else {\n      const position = this._getSecondPointerPosition(event);\n      const x = 0.5 * (event.pageX + position.x);\n      const y = 0.5 * (event.pageY + position.y);\n      this._panEnd.set(x, y);\n    }\n    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed);\n    this._pan(this._panDelta.x, this._panDelta.y);\n    this._panStart.copy(this._panEnd);\n  }\n  _handleTouchMoveDolly(event) {\n    const position = this._getSecondPointerPosition(event);\n    const dx = event.pageX - position.x;\n    const dy = event.pageY - position.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    this._dollyEnd.set(0, distance);\n    this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed));\n    this._dollyOut(this._dollyDelta.y);\n    this._dollyStart.copy(this._dollyEnd);\n    const centerX = (event.pageX + position.x) * 0.5;\n    const centerY = (event.pageY + position.y) * 0.5;\n    this._updateZoomParameters(centerX, centerY);\n  }\n  _handleTouchMoveDollyPan(event) {\n    if (this.enableZoom) this._handleTouchMoveDolly(event);\n    if (this.enablePan) this._handleTouchMovePan(event);\n  }\n  _handleTouchMoveDollyRotate(event) {\n    if (this.enableZoom) this._handleTouchMoveDolly(event);\n    if (this.enableRotate) this._handleTouchMoveRotate(event);\n  }\n\n  // pointers\n\n  _addPointer(event) {\n    this._pointers.push(event.pointerId);\n  }\n  _removePointer(event) {\n    delete this._pointerPositions[event.pointerId];\n    for (let i = 0; i < this._pointers.length; i++) {\n      if (this._pointers[i] == event.pointerId) {\n        this._pointers.splice(i, 1);\n        return;\n      }\n    }\n  }\n  _isTrackingPointer(event) {\n    for (let i = 0; i < this._pointers.length; i++) {\n      if (this._pointers[i] == event.pointerId) return true;\n    }\n    return false;\n  }\n  _trackPointer(event) {\n    let position = this._pointerPositions[event.pointerId];\n    if (position === undefined) {\n      position = new Vector2();\n      this._pointerPositions[event.pointerId] = position;\n    }\n    position.set(event.pageX, event.pageY);\n  }\n  _getSecondPointerPosition(event) {\n    const pointerId = event.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];\n    return this._pointerPositions[pointerId];\n  }\n\n  //\n\n  _customWheelEvent(event) {\n    const mode = event.deltaMode;\n\n    // minimal wheel event altered to meet delta-zoom demand\n    const newEvent = {\n      clientX: event.clientX,\n      clientY: event.clientY,\n      deltaY: event.deltaY\n    };\n    switch (mode) {\n      case 1:\n        // LINE_MODE\n        newEvent.deltaY *= 16;\n        break;\n      case 2:\n        // PAGE_MODE\n        newEvent.deltaY *= 100;\n        break;\n    }\n\n    // detect if event was triggered by pinching\n    if (event.ctrlKey && !this._controlActive) {\n      newEvent.deltaY *= 10;\n    }\n    return newEvent;\n  }\n}\nfunction onPointerDown(event) {\n  if (this.enabled === false) return;\n  if (this._pointers.length === 0) {\n    this.domElement.setPointerCapture(event.pointerId);\n    this.domElement.addEventListener('pointermove', this._onPointerMove);\n    this.domElement.addEventListener('pointerup', this._onPointerUp);\n  }\n\n  //\n\n  if (this._isTrackingPointer(event)) return;\n\n  //\n\n  this._addPointer(event);\n  if (event.pointerType === 'touch') {\n    this._onTouchStart(event);\n  } else {\n    this._onMouseDown(event);\n  }\n}\nfunction onPointerMove(event) {\n  if (this.enabled === false) return;\n  if (event.pointerType === 'touch') {\n    this._onTouchMove(event);\n  } else {\n    this._onMouseMove(event);\n  }\n}\nfunction onPointerUp(event) {\n  this._removePointer(event);\n  switch (this._pointers.length) {\n    case 0:\n      this.domElement.releasePointerCapture(event.pointerId);\n      this.domElement.removeEventListener('pointermove', this._onPointerMove);\n      this.domElement.removeEventListener('pointerup', this._onPointerUp);\n      this.dispatchEvent(_endEvent);\n      this.state = _STATE.NONE;\n      break;\n    case 1:\n      const pointerId = this._pointers[0];\n      const position = this._pointerPositions[pointerId];\n\n      // minimal placeholder event - allows state correction on pointer-up\n      this._onTouchStart({\n        pointerId: pointerId,\n        pageX: position.x,\n        pageY: position.y\n      });\n      break;\n  }\n}\nfunction onMouseDown(event) {\n  let mouseAction;\n  switch (event.button) {\n    case 0:\n      mouseAction = this.mouseButtons.LEFT;\n      break;\n    case 1:\n      mouseAction = this.mouseButtons.MIDDLE;\n      break;\n    case 2:\n      mouseAction = this.mouseButtons.RIGHT;\n      break;\n    default:\n      mouseAction = -1;\n  }\n  switch (mouseAction) {\n    case MOUSE.DOLLY:\n      if (this.enableZoom === false) return;\n      this._handleMouseDownDolly(event);\n      this.state = _STATE.DOLLY;\n      break;\n    case MOUSE.ROTATE:\n      if (event.ctrlKey || event.metaKey || event.shiftKey) {\n        if (this.enablePan === false) return;\n        this._handleMouseDownPan(event);\n        this.state = _STATE.PAN;\n      } else {\n        if (this.enableRotate === false) return;\n        this._handleMouseDownRotate(event);\n        this.state = _STATE.ROTATE;\n      }\n      break;\n    case MOUSE.PAN:\n      if (event.ctrlKey || event.metaKey || event.shiftKey) {\n        if (this.enableRotate === false) return;\n        this._handleMouseDownRotate(event);\n        this.state = _STATE.ROTATE;\n      } else {\n        if (this.enablePan === false) return;\n        this._handleMouseDownPan(event);\n        this.state = _STATE.PAN;\n      }\n      break;\n    default:\n      this.state = _STATE.NONE;\n  }\n  if (this.state !== _STATE.NONE) {\n    this.dispatchEvent(_startEvent);\n  }\n}\nfunction onMouseMove(event) {\n  switch (this.state) {\n    case _STATE.ROTATE:\n      if (this.enableRotate === false) return;\n      this._handleMouseMoveRotate(event);\n      break;\n    case _STATE.DOLLY:\n      if (this.enableZoom === false) return;\n      this._handleMouseMoveDolly(event);\n      break;\n    case _STATE.PAN:\n      if (this.enablePan === false) return;\n      this._handleMouseMovePan(event);\n      break;\n  }\n}\nfunction onMouseWheel(event) {\n  if (this.enabled === false || this.enableZoom === false || this.state !== _STATE.NONE) return;\n  event.preventDefault();\n  this.dispatchEvent(_startEvent);\n  this._handleMouseWheel(this._customWheelEvent(event));\n  this.dispatchEvent(_endEvent);\n}\nfunction onKeyDown(event) {\n  if (this.enabled === false || this.enablePan === false) return;\n  this._handleKeyDown(event);\n}\nfunction onTouchStart(event) {\n  this._trackPointer(event);\n  switch (this._pointers.length) {\n    case 1:\n      switch (this.touches.ONE) {\n        case TOUCH.ROTATE:\n          if (this.enableRotate === false) return;\n          this._handleTouchStartRotate(event);\n          this.state = _STATE.TOUCH_ROTATE;\n          break;\n        case TOUCH.PAN:\n          if (this.enablePan === false) return;\n          this._handleTouchStartPan(event);\n          this.state = _STATE.TOUCH_PAN;\n          break;\n        default:\n          this.state = _STATE.NONE;\n      }\n      break;\n    case 2:\n      switch (this.touches.TWO) {\n        case TOUCH.DOLLY_PAN:\n          if (this.enableZoom === false && this.enablePan === false) return;\n          this._handleTouchStartDollyPan(event);\n          this.state = _STATE.TOUCH_DOLLY_PAN;\n          break;\n        case TOUCH.DOLLY_ROTATE:\n          if (this.enableZoom === false && this.enableRotate === false) return;\n          this._handleTouchStartDollyRotate(event);\n          this.state = _STATE.TOUCH_DOLLY_ROTATE;\n          break;\n        default:\n          this.state = _STATE.NONE;\n      }\n      break;\n    default:\n      this.state = _STATE.NONE;\n  }\n  if (this.state !== _STATE.NONE) {\n    this.dispatchEvent(_startEvent);\n  }\n}\nfunction onTouchMove(event) {\n  this._trackPointer(event);\n  switch (this.state) {\n    case _STATE.TOUCH_ROTATE:\n      if (this.enableRotate === false) return;\n      this._handleTouchMoveRotate(event);\n      this.update();\n      break;\n    case _STATE.TOUCH_PAN:\n      if (this.enablePan === false) return;\n      this._handleTouchMovePan(event);\n      this.update();\n      break;\n    case _STATE.TOUCH_DOLLY_PAN:\n      if (this.enableZoom === false && this.enablePan === false) return;\n      this._handleTouchMoveDollyPan(event);\n      this.update();\n      break;\n    case _STATE.TOUCH_DOLLY_ROTATE:\n      if (this.enableZoom === false && this.enableRotate === false) return;\n      this._handleTouchMoveDollyRotate(event);\n      this.update();\n      break;\n    default:\n      this.state = _STATE.NONE;\n  }\n}\nfunction onContextMenu(event) {\n  if (this.enabled === false) return;\n  event.preventDefault();\n}\nfunction interceptControlDown(event) {\n  if (event.key === 'Control') {\n    this._controlActive = true;\n    const document = this.domElement.getRootNode(); // offscreen canvas compatibility\n\n    document.addEventListener('keyup', this._interceptControlUp, {\n      passive: true,\n      capture: true\n    });\n  }\n}\nfunction interceptControlUp(event) {\n  if (event.key === 'Control') {\n    this._controlActive = false;\n    const document = this.domElement.getRootNode(); // offscreen canvas compatibility\n\n    document.removeEventListener('keyup', this._interceptControlUp, {\n      passive: true,\n      capture: true\n    });\n  }\n}\nexport { OrbitControls };","map":null,"metadata":{},"sourceType":"module"}