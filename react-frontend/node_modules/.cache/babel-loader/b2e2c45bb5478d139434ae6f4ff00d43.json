{"ast":null,"code":"import { BufferGeometry, Float32BufferAttribute } from 'three';\nimport { flatten } from 'earcut';\nimport { geoDistance, geoInterpolate } from 'd3-geo';\nfunction _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nfunction _arrayWithHoles(r) {\n  if (Array.isArray(r)) return r;\n}\nfunction _assertThisInitialized(e) {\n  if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\nfunction _callSuper(t, o, e) {\n  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _createClass(e, r, t) {\n  return Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), e;\n}\nfunction _createForOfIteratorHelper(r, e) {\n  var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (!t) {\n    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) {\n      t && (r = t);\n      var n = 0,\n        F = function () {};\n      return {\n        s: F,\n        n: function () {\n          return n >= r.length ? {\n            done: !0\n          } : {\n            done: !1,\n            value: r[n++]\n          };\n        },\n        e: function (r) {\n          throw r;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var o,\n    a = !0,\n    u = !1;\n  return {\n    s: function () {\n      t = t.call(r);\n    },\n    n: function () {\n      var r = t.next();\n      return a = r.done, r;\n    },\n    e: function (r) {\n      u = !0, o = r;\n    },\n    f: function () {\n      try {\n        a || null == t.return || t.return();\n      } finally {\n        if (u) throw o;\n      }\n    }\n  };\n}\nfunction _getPrototypeOf(t) {\n  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  }, _getPrototypeOf(t);\n}\nfunction _inherits(t, e) {\n  if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n  t.prototype = Object.create(e && e.prototype, {\n    constructor: {\n      value: t,\n      writable: !0,\n      configurable: !0\n    }\n  }), Object.defineProperty(t, \"prototype\", {\n    writable: !1\n  }), e && _setPrototypeOf(t, e);\n}\nfunction _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function () {\n    return !!t;\n  })();\n}\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _possibleConstructorReturn(t, e) {\n  if (e && (\"object\" == typeof e || \"function\" == typeof e)) return e;\n  if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return _assertThisInitialized(t);\n}\nfunction _setPrototypeOf(t, e) {\n  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n    return t.__proto__ = e, t;\n  }, _setPrototypeOf(t, e);\n}\nfunction _slicedToArray(r, e) {\n  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n}\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n  }\n}\nvar interpolateLine = function interpolateLine() {\n  var lineCoords = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var maxDegDistance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var result = [];\n  var prevPnt = null;\n  lineCoords.forEach(function (pnt) {\n    if (prevPnt) {\n      var dist = geoDistance(pnt, prevPnt) * 180 / Math.PI;\n      if (dist > maxDegDistance) {\n        var interpol = geoInterpolate(prevPnt, pnt);\n        var tStep = 1 / Math.ceil(dist / maxDegDistance);\n        var t = tStep;\n        while (t < 1) {\n          result.push(interpol(t));\n          t += tStep;\n        }\n      }\n    }\n    result.push(prevPnt = pnt);\n  });\n  return result;\n};\nvar THREE = typeof window !== 'undefined' && window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  BufferGeometry: BufferGeometry,\n  Float32BufferAttribute: Float32BufferAttribute\n};\n\n// support both modes for backwards threejs compatibility\nvar setAttributeFn = new THREE.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\nvar GeoJsonGeometry = /*#__PURE__*/function (_THREE$BufferGeometry) {\n  function GeoJsonGeometry(geoJson) {\n    var _this;\n    var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var resolution = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;\n    _classCallCheck(this, GeoJsonGeometry);\n    _this = _callSuper(this, GeoJsonGeometry);\n    _this.type = 'GeoJsonGeometry';\n    _this.parameters = {\n      geoJson: geoJson,\n      radius: radius,\n      resolution: resolution\n    };\n\n    // process various geometry types\n    var groups = ({\n      Point: genPoint,\n      MultiPoint: genMultiPoint,\n      LineString: genLineString,\n      MultiLineString: genMultiLineString,\n      Polygon: genPolygon,\n      MultiPolygon: genMultiPolygon\n    }[geoJson.type] || function () {\n      return [];\n    })(geoJson.coordinates, radius);\n\n    // concat groups\n    var indices = [],\n      vertices = [];\n    var groupCnt = 0;\n    groups.forEach(function (newG) {\n      var prevIndCnt = indices.length;\n      concatGroup({\n        indices: indices,\n        vertices: vertices\n      }, newG);\n      _this.addGroup(prevIndCnt, indices.length - prevIndCnt, groupCnt++);\n    });\n\n    // build geometry\n    indices.length && _this.setIndex(indices);\n    vertices.length && _this[setAttributeFn]('position', new THREE.Float32BufferAttribute(vertices, 3));\n\n    //\n\n    function genPoint(coords, r) {\n      var vertices = polar2Cartesian(coords[1], coords[0], r);\n      var indices = [];\n      return [{\n        vertices: vertices,\n        indices: indices\n      }];\n    }\n    function genMultiPoint(coords, r) {\n      var result = {\n        vertices: [],\n        indices: []\n      };\n      coords.map(function (c) {\n        return genPoint(c, r);\n      }).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 1),\n          newPnt = _ref2[0];\n        concatGroup(result, newPnt);\n      });\n      return [result];\n    }\n    function genLineString(coords, r) {\n      var coords3d = interpolateLine(coords, resolution).map(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n          lng = _ref4[0],\n          lat = _ref4[1];\n        return polar2Cartesian(lat, lng, r);\n      });\n      var _earcutFlatten = flatten([coords3d]),\n        vertices = _earcutFlatten.vertices;\n      var numPoints = Math.round(vertices.length / 3);\n      var indices = [];\n      for (var vIdx = 1; vIdx < numPoints; vIdx++) {\n        indices.push(vIdx - 1, vIdx);\n      }\n      return [{\n        vertices: vertices,\n        indices: indices\n      }];\n    }\n    function genMultiLineString(coords, r) {\n      var result = {\n        vertices: [],\n        indices: []\n      };\n      coords.map(function (c) {\n        return genLineString(c, r);\n      }).forEach(function (_ref5) {\n        var _ref6 = _slicedToArray(_ref5, 1),\n          newLine = _ref6[0];\n        concatGroup(result, newLine);\n      });\n      return [result];\n    }\n    function genPolygon(coords, r) {\n      var coords3d = coords.map(function (coordsSegment) {\n        return interpolateLine(coordsSegment, resolution).map(function (_ref7) {\n          var _ref8 = _slicedToArray(_ref7, 2),\n            lng = _ref8[0],\n            lat = _ref8[1];\n          return polar2Cartesian(lat, lng, r);\n        });\n      });\n\n      // Each point generates 3 vertice items (x,y,z).\n      var _earcutFlatten2 = flatten(coords3d),\n        vertices = _earcutFlatten2.vertices,\n        holes = _earcutFlatten2.holes;\n      var firstHoleIdx = holes[0] || Infinity;\n      var outerVertices = vertices.slice(0, firstHoleIdx * 3);\n      var holeVertices = vertices.slice(firstHoleIdx * 3);\n      var holesIdx = new Set(holes);\n      var numPoints = Math.round(vertices.length / 3);\n      var outerIndices = [],\n        holeIndices = [];\n      for (var vIdx = 1; vIdx < numPoints; vIdx++) {\n        if (!holesIdx.has(vIdx)) {\n          if (vIdx < firstHoleIdx) {\n            outerIndices.push(vIdx - 1, vIdx);\n          } else {\n            holeIndices.push(vIdx - 1 - firstHoleIdx, vIdx - firstHoleIdx);\n          }\n        }\n      }\n      var groups = [{\n        indices: outerIndices,\n        vertices: outerVertices\n      }];\n      if (holes.length) {\n        groups.push({\n          indices: holeIndices,\n          vertices: holeVertices\n        });\n      }\n      return groups;\n    }\n    function genMultiPolygon(coords, r) {\n      var outer = {\n        vertices: [],\n        indices: []\n      };\n      var holes = {\n        vertices: [],\n        indices: []\n      };\n      coords.map(function (c) {\n        return genPolygon(c, r);\n      }).forEach(function (_ref9) {\n        var _ref10 = _slicedToArray(_ref9, 2),\n          newOuter = _ref10[0],\n          newHoles = _ref10[1];\n        concatGroup(outer, newOuter);\n        newHoles && concatGroup(holes, newHoles);\n      });\n      var groups = [outer];\n      holes.vertices.length && groups.push(holes);\n      return groups;\n    }\n    return _this;\n  }\n  _inherits(GeoJsonGeometry, _THREE$BufferGeometry);\n  return _createClass(GeoJsonGeometry);\n}(THREE.BufferGeometry); //\nfunction concatGroup(main, extra) {\n  var prevVertCnt = Math.round(main.vertices.length / 3);\n  concatArr(main.vertices, extra.vertices);\n  concatArr(main.indices, extra.indices.map(function (ind) {\n    return ind + prevVertCnt;\n  }));\n}\nfunction concatArr(target, src) {\n  var _iterator = _createForOfIteratorHelper(src),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var e = _step.value;\n      target.push(e);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\nfunction polar2Cartesian(lat, lng) {\n  var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var phi = (90 - lat) * Math.PI / 180;\n  var theta = (90 - lng) * Math.PI / 180;\n  return [r * Math.sin(phi) * Math.cos(theta),\n  // x\n  r * Math.cos(phi),\n  // y\n  r * Math.sin(phi) * Math.sin(theta) // z\n  ];\n}\nexport { GeoJsonGeometry };","map":null,"metadata":{},"sourceType":"module"}