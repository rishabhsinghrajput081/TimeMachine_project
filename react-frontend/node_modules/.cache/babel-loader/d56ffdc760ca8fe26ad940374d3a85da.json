{"ast":null,"code":"import { Controls, MathUtils, MOUSE, Quaternion, Vector2, Vector3 } from 'three';\nconst _changeEvent = {\n  type: 'change'\n};\nconst _startEvent = {\n  type: 'start'\n};\nconst _endEvent = {\n  type: 'end'\n};\nconst _EPS = 0.000001;\nconst _STATE = {\n  NONE: -1,\n  ROTATE: 0,\n  ZOOM: 1,\n  PAN: 2,\n  TOUCH_ROTATE: 3,\n  TOUCH_ZOOM_PAN: 4\n};\nconst _v2 = new Vector2();\nconst _mouseChange = new Vector2();\nconst _objectUp = new Vector3();\nconst _pan = new Vector3();\nconst _axis = new Vector3();\nconst _quaternion = new Quaternion();\nconst _eyeDirection = new Vector3();\nconst _objectUpDirection = new Vector3();\nconst _objectSidewaysDirection = new Vector3();\nconst _moveDirection = new Vector3();\nclass TrackballControls extends Controls {\n  constructor(object, domElement = null) {\n    super(object, domElement);\n\n    // API\n\n    this.enabled = true;\n    this.screen = {\n      left: 0,\n      top: 0,\n      width: 0,\n      height: 0\n    };\n    this.rotateSpeed = 1.0;\n    this.zoomSpeed = 1.2;\n    this.panSpeed = 0.3;\n    this.noRotate = false;\n    this.noZoom = false;\n    this.noPan = false;\n    this.staticMoving = false;\n    this.dynamicDampingFactor = 0.2;\n    this.minDistance = 0;\n    this.maxDistance = Infinity;\n    this.minZoom = 0;\n    this.maxZoom = Infinity;\n    this.keys = ['KeyA' /*A*/, 'KeyS' /*S*/, 'KeyD' /*D*/];\n    this.mouseButtons = {\n      LEFT: MOUSE.ROTATE,\n      MIDDLE: MOUSE.DOLLY,\n      RIGHT: MOUSE.PAN\n    };\n    this.state = _STATE.NONE;\n    this.keyState = _STATE.NONE;\n    this.target = new Vector3();\n\n    // internals\n\n    this._lastPosition = new Vector3();\n    this._lastZoom = 1;\n    this._touchZoomDistanceStart = 0;\n    this._touchZoomDistanceEnd = 0;\n    this._lastAngle = 0;\n    this._eye = new Vector3();\n    this._movePrev = new Vector2();\n    this._moveCurr = new Vector2();\n    this._lastAxis = new Vector3();\n    this._zoomStart = new Vector2();\n    this._zoomEnd = new Vector2();\n    this._panStart = new Vector2();\n    this._panEnd = new Vector2();\n    this._pointers = [];\n    this._pointerPositions = {};\n\n    // event listeners\n\n    this._onPointerMove = onPointerMove.bind(this);\n    this._onPointerDown = onPointerDown.bind(this);\n    this._onPointerUp = onPointerUp.bind(this);\n    this._onPointerCancel = onPointerCancel.bind(this);\n    this._onContextMenu = onContextMenu.bind(this);\n    this._onMouseWheel = onMouseWheel.bind(this);\n    this._onKeyDown = onKeyDown.bind(this);\n    this._onKeyUp = onKeyUp.bind(this);\n    this._onTouchStart = onTouchStart.bind(this);\n    this._onTouchMove = onTouchMove.bind(this);\n    this._onTouchEnd = onTouchEnd.bind(this);\n    this._onMouseDown = onMouseDown.bind(this);\n    this._onMouseMove = onMouseMove.bind(this);\n    this._onMouseUp = onMouseUp.bind(this);\n\n    // for reset\n\n    this._target0 = this.target.clone();\n    this._position0 = this.object.position.clone();\n    this._up0 = this.object.up.clone();\n    this._zoom0 = this.object.zoom;\n    if (domElement !== null) {\n      this.connect();\n      this.handleResize();\n    }\n\n    // force an update at start\n    this.update();\n  }\n  connect() {\n    window.addEventListener('keydown', this._onKeyDown);\n    window.addEventListener('keyup', this._onKeyUp);\n    this.domElement.addEventListener('pointerdown', this._onPointerDown);\n    this.domElement.addEventListener('pointercancel', this._onPointerCancel);\n    this.domElement.addEventListener('wheel', this._onMouseWheel, {\n      passive: false\n    });\n    this.domElement.addEventListener('contextmenu', this._onContextMenu);\n    this.domElement.style.touchAction = 'none'; // disable touch scroll\n  }\n  disconnect() {\n    window.removeEventListener('keydown', this._onKeyDown);\n    window.removeEventListener('keyup', this._onKeyUp);\n    this.domElement.removeEventListener('pointerdown', this._onPointerDown);\n    this.domElement.removeEventListener('pointermove', this._onPointerMove);\n    this.domElement.removeEventListener('pointerup', this._onPointerUp);\n    this.domElement.removeEventListener('pointercancel', this._onPointerCancel);\n    this.domElement.removeEventListener('wheel', this._onMouseWheel);\n    this.domElement.removeEventListener('contextmenu', this._onContextMenu);\n    this.domElement.style.touchAction = 'auto'; // disable touch scroll\n  }\n  dispose() {\n    this.disconnect();\n  }\n  handleResize() {\n    const box = this.domElement.getBoundingClientRect();\n    // adjustments come from similar code in the jquery offset() function\n    const d = this.domElement.ownerDocument.documentElement;\n    this.screen.left = box.left + window.pageXOffset - d.clientLeft;\n    this.screen.top = box.top + window.pageYOffset - d.clientTop;\n    this.screen.width = box.width;\n    this.screen.height = box.height;\n  }\n  update() {\n    this._eye.subVectors(this.object.position, this.target);\n    if (!this.noRotate) {\n      this._rotateCamera();\n    }\n    if (!this.noZoom) {\n      this._zoomCamera();\n    }\n    if (!this.noPan) {\n      this._panCamera();\n    }\n    this.object.position.addVectors(this.target, this._eye);\n    if (this.object.isPerspectiveCamera) {\n      this._checkDistances();\n      this.object.lookAt(this.target);\n      if (this._lastPosition.distanceToSquared(this.object.position) > _EPS) {\n        this.dispatchEvent(_changeEvent);\n        this._lastPosition.copy(this.object.position);\n      }\n    } else if (this.object.isOrthographicCamera) {\n      this.object.lookAt(this.target);\n      if (this._lastPosition.distanceToSquared(this.object.position) > _EPS || this._lastZoom !== this.object.zoom) {\n        this.dispatchEvent(_changeEvent);\n        this._lastPosition.copy(this.object.position);\n        this._lastZoom = this.object.zoom;\n      }\n    } else {\n      console.warn('THREE.TrackballControls: Unsupported camera type.');\n    }\n  }\n  reset() {\n    this.state = _STATE.NONE;\n    this.keyState = _STATE.NONE;\n    this.target.copy(this._target0);\n    this.object.position.copy(this._position0);\n    this.object.up.copy(this._up0);\n    this.object.zoom = this._zoom0;\n    this.object.updateProjectionMatrix();\n    this._eye.subVectors(this.object.position, this.target);\n    this.object.lookAt(this.target);\n    this.dispatchEvent(_changeEvent);\n    this._lastPosition.copy(this.object.position);\n    this._lastZoom = this.object.zoom;\n  }\n  _panCamera() {\n    _mouseChange.copy(this._panEnd).sub(this._panStart);\n    if (_mouseChange.lengthSq()) {\n      if (this.object.isOrthographicCamera) {\n        const scale_x = (this.object.right - this.object.left) / this.object.zoom / this.domElement.clientWidth;\n        const scale_y = (this.object.top - this.object.bottom) / this.object.zoom / this.domElement.clientWidth;\n        _mouseChange.x *= scale_x;\n        _mouseChange.y *= scale_y;\n      }\n      _mouseChange.multiplyScalar(this._eye.length() * this.panSpeed);\n      _pan.copy(this._eye).cross(this.object.up).setLength(_mouseChange.x);\n      _pan.add(_objectUp.copy(this.object.up).setLength(_mouseChange.y));\n      this.object.position.add(_pan);\n      this.target.add(_pan);\n      if (this.staticMoving) {\n        this._panStart.copy(this._panEnd);\n      } else {\n        this._panStart.add(_mouseChange.subVectors(this._panEnd, this._panStart).multiplyScalar(this.dynamicDampingFactor));\n      }\n    }\n  }\n  _rotateCamera() {\n    _moveDirection.set(this._moveCurr.x - this._movePrev.x, this._moveCurr.y - this._movePrev.y, 0);\n    let angle = _moveDirection.length();\n    if (angle) {\n      this._eye.copy(this.object.position).sub(this.target);\n      _eyeDirection.copy(this._eye).normalize();\n      _objectUpDirection.copy(this.object.up).normalize();\n      _objectSidewaysDirection.crossVectors(_objectUpDirection, _eyeDirection).normalize();\n      _objectUpDirection.setLength(this._moveCurr.y - this._movePrev.y);\n      _objectSidewaysDirection.setLength(this._moveCurr.x - this._movePrev.x);\n      _moveDirection.copy(_objectUpDirection.add(_objectSidewaysDirection));\n      _axis.crossVectors(_moveDirection, this._eye).normalize();\n      angle *= this.rotateSpeed;\n      _quaternion.setFromAxisAngle(_axis, angle);\n      this._eye.applyQuaternion(_quaternion);\n      this.object.up.applyQuaternion(_quaternion);\n      this._lastAxis.copy(_axis);\n      this._lastAngle = angle;\n    } else if (!this.staticMoving && this._lastAngle) {\n      this._lastAngle *= Math.sqrt(1.0 - this.dynamicDampingFactor);\n      this._eye.copy(this.object.position).sub(this.target);\n      _quaternion.setFromAxisAngle(this._lastAxis, this._lastAngle);\n      this._eye.applyQuaternion(_quaternion);\n      this.object.up.applyQuaternion(_quaternion);\n    }\n    this._movePrev.copy(this._moveCurr);\n  }\n  _zoomCamera() {\n    let factor;\n    if (this.state === _STATE.TOUCH_ZOOM_PAN) {\n      factor = this._touchZoomDistanceStart / this._touchZoomDistanceEnd;\n      this._touchZoomDistanceStart = this._touchZoomDistanceEnd;\n      if (this.object.isPerspectiveCamera) {\n        this._eye.multiplyScalar(factor);\n      } else if (this.object.isOrthographicCamera) {\n        this.object.zoom = MathUtils.clamp(this.object.zoom / factor, this.minZoom, this.maxZoom);\n        if (this._lastZoom !== this.object.zoom) {\n          this.object.updateProjectionMatrix();\n        }\n      } else {\n        console.warn('THREE.TrackballControls: Unsupported camera type');\n      }\n    } else {\n      factor = 1.0 + (this._zoomEnd.y - this._zoomStart.y) * this.zoomSpeed;\n      if (factor !== 1.0 && factor > 0.0) {\n        if (this.object.isPerspectiveCamera) {\n          this._eye.multiplyScalar(factor);\n        } else if (this.object.isOrthographicCamera) {\n          this.object.zoom = MathUtils.clamp(this.object.zoom / factor, this.minZoom, this.maxZoom);\n          if (this._lastZoom !== this.object.zoom) {\n            this.object.updateProjectionMatrix();\n          }\n        } else {\n          console.warn('THREE.TrackballControls: Unsupported camera type');\n        }\n      }\n      if (this.staticMoving) {\n        this._zoomStart.copy(this._zoomEnd);\n      } else {\n        this._zoomStart.y += (this._zoomEnd.y - this._zoomStart.y) * this.dynamicDampingFactor;\n      }\n    }\n  }\n  _getMouseOnScreen(pageX, pageY) {\n    _v2.set((pageX - this.screen.left) / this.screen.width, (pageY - this.screen.top) / this.screen.height);\n    return _v2;\n  }\n  _getMouseOnCircle(pageX, pageY) {\n    _v2.set((pageX - this.screen.width * 0.5 - this.screen.left) / (this.screen.width * 0.5), (this.screen.height + 2 * (this.screen.top - pageY)) / this.screen.width // screen.width intentional\n    );\n    return _v2;\n  }\n  _addPointer(event) {\n    this._pointers.push(event);\n  }\n  _removePointer(event) {\n    delete this._pointerPositions[event.pointerId];\n    for (let i = 0; i < this._pointers.length; i++) {\n      if (this._pointers[i].pointerId == event.pointerId) {\n        this._pointers.splice(i, 1);\n        return;\n      }\n    }\n  }\n  _trackPointer(event) {\n    let position = this._pointerPositions[event.pointerId];\n    if (position === undefined) {\n      position = new Vector2();\n      this._pointerPositions[event.pointerId] = position;\n    }\n    position.set(event.pageX, event.pageY);\n  }\n  _getSecondPointerPosition(event) {\n    const pointer = event.pointerId === this._pointers[0].pointerId ? this._pointers[1] : this._pointers[0];\n    return this._pointerPositions[pointer.pointerId];\n  }\n  _checkDistances() {\n    if (!this.noZoom || !this.noPan) {\n      if (this._eye.lengthSq() > this.maxDistance * this.maxDistance) {\n        this.object.position.addVectors(this.target, this._eye.setLength(this.maxDistance));\n        this._zoomStart.copy(this._zoomEnd);\n      }\n      if (this._eye.lengthSq() < this.minDistance * this.minDistance) {\n        this.object.position.addVectors(this.target, this._eye.setLength(this.minDistance));\n        this._zoomStart.copy(this._zoomEnd);\n      }\n    }\n  }\n}\nfunction onPointerDown(event) {\n  if (this.enabled === false) return;\n  if (this._pointers.length === 0) {\n    this.domElement.setPointerCapture(event.pointerId);\n    this.domElement.addEventListener('pointermove', this._onPointerMove);\n    this.domElement.addEventListener('pointerup', this._onPointerUp);\n  }\n\n  //\n\n  this._addPointer(event);\n  if (event.pointerType === 'touch') {\n    this._onTouchStart(event);\n  } else {\n    this._onMouseDown(event);\n  }\n}\nfunction onPointerMove(event) {\n  if (this.enabled === false) return;\n  if (event.pointerType === 'touch') {\n    this._onTouchMove(event);\n  } else {\n    this._onMouseMove(event);\n  }\n}\nfunction onPointerUp(event) {\n  if (this.enabled === false) return;\n  if (event.pointerType === 'touch') {\n    this._onTouchEnd(event);\n  } else {\n    this._onMouseUp();\n  }\n\n  //\n\n  this._removePointer(event);\n  if (this._pointers.length === 0) {\n    this.domElement.releasePointerCapture(event.pointerId);\n    this.domElement.removeEventListener('pointermove', this._onPointerMove);\n    this.domElement.removeEventListener('pointerup', this._onPointerUp);\n  }\n}\nfunction onPointerCancel(event) {\n  this._removePointer(event);\n}\nfunction onKeyUp() {\n  if (this.enabled === false) return;\n  this.keyState = _STATE.NONE;\n  window.addEventListener('keydown', this._onKeyDown);\n}\nfunction onKeyDown(event) {\n  if (this.enabled === false) return;\n  window.removeEventListener('keydown', this._onKeyDown);\n  if (this.keyState !== _STATE.NONE) {\n    return;\n  } else if (event.code === this.keys[_STATE.ROTATE] && !this.noRotate) {\n    this.keyState = _STATE.ROTATE;\n  } else if (event.code === this.keys[_STATE.ZOOM] && !this.noZoom) {\n    this.keyState = _STATE.ZOOM;\n  } else if (event.code === this.keys[_STATE.PAN] && !this.noPan) {\n    this.keyState = _STATE.PAN;\n  }\n}\nfunction onMouseDown(event) {\n  let mouseAction;\n  switch (event.button) {\n    case 0:\n      mouseAction = this.mouseButtons.LEFT;\n      break;\n    case 1:\n      mouseAction = this.mouseButtons.MIDDLE;\n      break;\n    case 2:\n      mouseAction = this.mouseButtons.RIGHT;\n      break;\n    default:\n      mouseAction = -1;\n  }\n  switch (mouseAction) {\n    case MOUSE.DOLLY:\n      this.state = _STATE.ZOOM;\n      break;\n    case MOUSE.ROTATE:\n      this.state = _STATE.ROTATE;\n      break;\n    case MOUSE.PAN:\n      this.state = _STATE.PAN;\n      break;\n    default:\n      this.state = _STATE.NONE;\n  }\n  const state = this.keyState !== _STATE.NONE ? this.keyState : this.state;\n  if (state === _STATE.ROTATE && !this.noRotate) {\n    this._moveCurr.copy(this._getMouseOnCircle(event.pageX, event.pageY));\n    this._movePrev.copy(this._moveCurr);\n  } else if (state === _STATE.ZOOM && !this.noZoom) {\n    this._zoomStart.copy(this._getMouseOnScreen(event.pageX, event.pageY));\n    this._zoomEnd.copy(this._zoomStart);\n  } else if (state === _STATE.PAN && !this.noPan) {\n    this._panStart.copy(this._getMouseOnScreen(event.pageX, event.pageY));\n    this._panEnd.copy(this._panStart);\n  }\n  this.dispatchEvent(_startEvent);\n}\nfunction onMouseMove(event) {\n  const state = this.keyState !== _STATE.NONE ? this.keyState : this.state;\n  if (state === _STATE.ROTATE && !this.noRotate) {\n    this._movePrev.copy(this._moveCurr);\n    this._moveCurr.copy(this._getMouseOnCircle(event.pageX, event.pageY));\n  } else if (state === _STATE.ZOOM && !this.noZoom) {\n    this._zoomEnd.copy(this._getMouseOnScreen(event.pageX, event.pageY));\n  } else if (state === _STATE.PAN && !this.noPan) {\n    this._panEnd.copy(this._getMouseOnScreen(event.pageX, event.pageY));\n  }\n}\nfunction onMouseUp() {\n  this.state = _STATE.NONE;\n  this.dispatchEvent(_endEvent);\n}\nfunction onMouseWheel(event) {\n  if (this.enabled === false) return;\n  if (this.noZoom === true) return;\n  event.preventDefault();\n  switch (event.deltaMode) {\n    case 2:\n      // Zoom in pages\n      this._zoomStart.y -= event.deltaY * 0.025;\n      break;\n    case 1:\n      // Zoom in lines\n      this._zoomStart.y -= event.deltaY * 0.01;\n      break;\n    default:\n      // undefined, 0, assume pixels\n      this._zoomStart.y -= event.deltaY * 0.00025;\n      break;\n  }\n  this.dispatchEvent(_startEvent);\n  this.dispatchEvent(_endEvent);\n}\nfunction onContextMenu(event) {\n  if (this.enabled === false) return;\n  event.preventDefault();\n}\nfunction onTouchStart(event) {\n  this._trackPointer(event);\n  switch (this._pointers.length) {\n    case 1:\n      this.state = _STATE.TOUCH_ROTATE;\n      this._moveCurr.copy(this._getMouseOnCircle(this._pointers[0].pageX, this._pointers[0].pageY));\n      this._movePrev.copy(this._moveCurr);\n      break;\n    default:\n      // 2 or more\n      this.state = _STATE.TOUCH_ZOOM_PAN;\n      const dx = this._pointers[0].pageX - this._pointers[1].pageX;\n      const dy = this._pointers[0].pageY - this._pointers[1].pageY;\n      this._touchZoomDistanceEnd = this._touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);\n      const x = (this._pointers[0].pageX + this._pointers[1].pageX) / 2;\n      const y = (this._pointers[0].pageY + this._pointers[1].pageY) / 2;\n      this._panStart.copy(this._getMouseOnScreen(x, y));\n      this._panEnd.copy(this._panStart);\n      break;\n  }\n  this.dispatchEvent(_startEvent);\n}\nfunction onTouchMove(event) {\n  this._trackPointer(event);\n  switch (this._pointers.length) {\n    case 1:\n      this._movePrev.copy(this._moveCurr);\n      this._moveCurr.copy(this._getMouseOnCircle(event.pageX, event.pageY));\n      break;\n    default:\n      // 2 or more\n\n      const position = this._getSecondPointerPosition(event);\n      const dx = event.pageX - position.x;\n      const dy = event.pageY - position.y;\n      this._touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);\n      const x = (event.pageX + position.x) / 2;\n      const y = (event.pageY + position.y) / 2;\n      this._panEnd.copy(this._getMouseOnScreen(x, y));\n      break;\n  }\n}\nfunction onTouchEnd(event) {\n  switch (this._pointers.length) {\n    case 0:\n      this.state = _STATE.NONE;\n      break;\n    case 1:\n      this.state = _STATE.TOUCH_ROTATE;\n      this._moveCurr.copy(this._getMouseOnCircle(event.pageX, event.pageY));\n      this._movePrev.copy(this._moveCurr);\n      break;\n    case 2:\n      this.state = _STATE.TOUCH_ZOOM_PAN;\n      for (let i = 0; i < this._pointers.length; i++) {\n        if (this._pointers[i].pointerId !== event.pointerId) {\n          const position = this._pointerPositions[this._pointers[i].pointerId];\n          this._moveCurr.copy(this._getMouseOnCircle(position.x, position.y));\n          this._movePrev.copy(this._moveCurr);\n          break;\n        }\n      }\n      break;\n  }\n  this.dispatchEvent(_endEvent);\n}\nexport { TrackballControls };","map":null,"metadata":{},"sourceType":"module"}